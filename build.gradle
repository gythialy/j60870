import org.asciidoctor.gradle.jvm.AsciidoctorTask

plugins {
    id 'biz.aQute.bnd.builder' version '7.0.0' apply false
    id 'org.asciidoctor.jvm.pdf' version '4.0.2' apply false
    id 'org.asciidoctor.jvm.convert' version '4.0.2' apply false
}

apply plugin: 'org.asciidoctor.jvm.convert'
apply plugin: 'org.asciidoctor.jvm.pdf'
apply from: "configuration.gradle"
try {
    apply from: "gitlabRelease.gradle"
} catch (Exception e) {
    // ignore
}

tasks.register('generateDocs', AsciidoctorTask) {
    sourceDir = file('src/docs/asciidoc')
    outputDir = file("${layout.buildDirectory.get().asFile}/generated-docs")

    resources {
        from(sourceDir) {
            include 'images/**'
            include 'common-settings.txt'
            include 'openmuc-asciidoc.css'
            include 'pdf-theme.yml'
        }
    }

    attributes('project-root': project.rootDir,
            'stylesdir': "${projectDir}/src/docs/asciidoc",
            'stylesheet': 'openmuc-asciidoc.css',
            "toc2": "left",
            "source-highlighter": "coderay",
            'pdf-theme': 'pdf-theme.yml')

    outputOptions {
        backends = ['html5', 'pdf']
    }

    doLast {
        copy {
            from "${outputDir}/html5"
            into 'docs'
            include 'j60870-doc.html'
            include 'images/**'
            rename 'j60870-doc.html', 'index.html'
        }

        copy {
            from "${outputDir}/pdf"
            into 'docs'
            include 'j60870-doc.pdf'
        }
    }

    baseDirFollowsSourceDir()


    forkOptions {
        jvmArgs = ['--add-opens', 'java.base/sun.nio.ch=ALL-UNNAMED',
                   '--add-opens', 'java.base/java.io=ALL-UNNAMED']
    }
}

configure(allprojects) {
    version = cfgVersion
}

configure(javaProjects) {

    apply plugin: "java"
    apply plugin: "eclipse"
    apply plugin: "maven-publish"
    apply plugin: "signing"
    apply plugin: "biz.aQute.bnd.builder"

    group = cfgGroup

    if (!project.properties.containsKey('cfgJavaVersion')) {
        project.ext {
            cfgJavaVersion = '1.8'
        }
    }

    java {
        sourceCompatibility = JavaVersion.toVersion(cfgJavaVersion)
        targetCompatibility = JavaVersion.toVersion(cfgJavaVersion)
    }

    repositories {
        mavenCentral()
        mavenLocal()
    }

    sourceSets {
        sample
        itest {
            compileClasspath += sourceSets.main.runtimeClasspath
        }
    }

    configurations {
        jacoco
        jacocoRuntime
    }

    dependencies {
        testImplementation group: "junit", name: "junit", version: "4.13.2"
        itestImplementation group: "junit", name: "junit", version: "4.13.2"

        jacoco group: 'org.jacoco', name: 'org.jacoco.ant', version: '0.8.10', classifier: 'nodeps'
        jacocoRuntime group: 'org.jacoco', name: 'org.jacoco.agent', version: '0.8.10', classifier: 'runtime'
    }

    jar {
        manifest {
            version = project.version.replace("-", ".");
        }
    }

    tasks.register('instrument') {
        ext.outputDir = layout.buildDirectory.dir('classes-instrumented').get().asFile.path
        doLast {
            ant.taskdef(name: 'instrument',
                    classname: 'org.jacoco.ant.InstrumentTask',
                    classpath: configurations.jacoco.asPath)


            sourceSets.main.output.classesDirs.each { f ->
                // Copy directories from main source to instrumented path
                copy {
                    from f
                    into layout.buildDirectory.dir('instrumented_classes').get().asFile
                }
            }

            ant.instrument(destdir: outputDir) {
                fileset(dir: layout.buildDirectory.dir('instrumented_classes').get().asFile.path)
            }
        }
    }

    instrument.configure {
        dependsOn classes
    }

    gradle.taskGraph.whenReady { graph ->
        if (graph.hasTask(instrument)) {
            tasks.withType(Test) {
                doFirst {
                    systemProperty 'jacoco-agent.destfile', layout.buildDirectory.file('jacoco/tests.exec').get().asFile.path
                    classpath = files(instrument.outputDir) + classpath + configurations.jacocoRuntime
                }
            }
        }
    }


    tasks.register('report') {
        doLast {
            def execFile = layout.buildDirectory.file('jacoco/tests.exec').get().asFile
            if (!execFile.exists()) {
                return;
            }
            ant.taskdef(name: 'report',
                    classname: 'org.jacoco.ant.ReportTask',
                    classpath: configurations.jacoco.asPath)
            ant.report() {
                executiondata {
                    ant.file(file: execFile.path)
                }
                structure(name: 'Example') {
                    classfiles {
                        fileset(dir: layout.buildDirectory.dir('instrumented_classes').get().asFile.path)
                    }
                    sourcefiles {
                        fileset(dir: 'src/main/java')
                    }
                }
                html(destdir: layout.buildDirectory.dir('reports/jacoco').get().asFile.path)
            }
        }
    }

    report.configure {
        dependsOn instrument
        dependsOn test
    }

    tasks.register('jarAll', Copy) {
        dependsOn(configurations.runtimeElements.getAllArtifacts().getBuildDependencies())

        from configurations.runtimeElements.getAllArtifacts().getFiles()
        if (cfgCopyDependencies) {
            if (cfgCopyToRoot) {
                into rootDir.getPath() + "/build/libs-all"
            } else {
                into layout.buildDirectory.dir("libs-all")
            }
            //includes all the dependencies:
            from configurations.runtimeClasspath
        } else {
            if (cfgCopyToRoot) {
                into rootDir.getPath() + "/build/libs-all"
            } else {
                into layout.buildDirectory.dir("libs-all")
            }
        }
    }

    build.dependsOn { generateDocs }
    build.dependsOn { jarAll }

    eclipse.pathVariables([GRADLE_USER_HOME: file(gradle.gradleUserHomeDir)])
    tasks.eclipse.dependsOn(cleanEclipse)

    tasks.register('sourcesJar', Jar) {
        dependsOn classes
        archiveClassifier = "sources"
        from sourceSets.main.allSource
    }

    tasks.register('javadocJar', Jar) {
        dependsOn javadoc
        archiveClassifier = "javadoc"
        from javadoc.destinationDir
    }

    artifacts {
        archives sourcesJar
        archives javadocJar
    }

    javadoc {
        exclude "**/internal/**"
        exclude "**/java-gen/**"
    }
}


configure(repositoryProjects) {

    publishing {
        publications {
            maven(MavenPublication) {
                artifact jar
                artifact sourcesJar
                artifact javadocJar

                pom {
                    packaging = "jar"
                    url = "https://www.openmuc.org/"

                    scm {
                        url = "none"
                        connection = "none"
                    }

                    developers {
                        developer {
                            id = "openmuc"
                            name = "OpenMUC Team"
                        }
                    }
                }
            }
        }

        repositories {
            maven {
                name = "release"
                url = version.endsWith('SNAPSHOT') ? cfgSnapshotRepository : cfgRepository
                credentials {
                    username = cfgRepositoryUser
                    password = cfgRepositoryPass
                }

                if (url != null && System.getProperty("https.proxyHost") != null && ((System.getProperty("https.nonProxyHosts") == null) || !url.toString().contains(System.getProperty("https.nonProxyHosts")))) {
                    // Note: Proxy configuration in publishing repositories works differently in Gradle 8.x
                    // You may need to configure this at the system level or through gradle.properties
                }
            }
        }
    }

    if (cfgSignPom) {
        signing {
            if (project.hasProperty("signing.keyId")) {
                sign publishing.publications.maven
            }
        }
    }
}

tasks.register('javadocAll', Javadoc) {

    source docProjects.collect { project -> project.sourceSets.main.allJava
    }

    exclude "**/internal/**"
    exclude "**/java-gen/**"
    exclude "**/app/**"

    destinationDir = layout.buildDirectory.dir("docs/javadoc-all").get().asFile

    classpath = files(distributionProjects.collect { project -> project.sourceSets.main.compileClasspath
    })

    classpath += files(distributionProjects.collect { project -> project.sourceSets.main.output
    })
}


tasks.register('writeSettings') {
    doLast {
        Writer out = new OutputStreamWriter(new FileOutputStream("build/settings.gradle"));
        out.write("include ");
        boolean first = true;
        for (Project myproject : distributionProjects) {
            if (myproject.getProjectDir() == getProjectDir()) {
                continue;
            }
            if (first) {
                first = false;
            } else {
                out.write ", ";
            }
            out.write '"' + myproject.name + '"'
        }
        out.write "\n\n";

        for (Project myproject : distributionProjects) {
            if (myproject.getProjectDir() == getProjectDir()) {
                continue;
            }
            println myproject.name
            out.write 'project(":' + myproject.name + '").projectDir = file("' + myproject.getProjectDir().toString().substring((int) (getProjectDir().toString().size() + 1)) + '")\n';
        }

        out.close();
    }
}

tasks.register('buildDistProjects') {
    dependsOn(distributionProjects.build)
}

tasks.withType(Tar) {
    dependsOn(writeSettings)
    dependsOn(distributionProjects.build)
    dependsOn(javadocAll)
    dependsOn(generateDocs)

    compression = Compression.GZIP

    destinationDirectory = layout.buildDirectory.dir("distributions")
}

tasks.register('tar', Tar) {
    archiveFileName = project.name + "-" + project.version + ".tgz"
}

tasks.register('tarFull', Tar) {
    dependsOn(tar)
    archiveFileName = project.name + "-" + project.version + "_full.tgz"
}

test {
    jvmArgs '--add-opens', 'java.base/java.lang=ALL-UNNAMED'
    jvmArgs '--add-opens', 'java.base/java.util=ALL-UNNAMED'
}
